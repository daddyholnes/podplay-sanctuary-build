"""
MCP Marketplace Manager - Real GitHub search and Docker MCP toolkit integration
Enables Mama Bear to autonomously discover, install, and manage MCP servers
"""

import os
import logging
import json
import asyncio
import subprocess
import requests
from datetime import datetime
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse, quote
import docker
from github import Github
import yaml

logger = logging.getLogger(__name__)

class MCPMarketplaceManager:
    """Manages MCP server discovery, installation, and empowerment capabilities"""
    
    def __init__(self):
        self.github_token = os.getenv('GITHUB_TOKEN')
        self.github_client = None
        self.docker_client = None
        self.installed_mcps = {}
        self.mcp_registry = self._load_mcp_registry()
        
        # Initialize GitHub client
        if self.github_token:
            try:
                self.github_client = Github(self.github_token)
                logger.info("ðŸ™ GitHub client initialized for MCP search")
            except Exception as e:
                logger.warning(f"âš ï¸ GitHub client initialization failed: {e}")
        
        # Initialize Docker client
        try:
            self.docker_client = docker.from_env()
            logger.info("ðŸ³ Docker client initialized for MCP containers")
        except Exception as e:
            logger.warning(f"âš ï¸ Docker client not available: {e}")
        
        logger.info("ðŸ”Œ MCP Marketplace Manager initialized")
    
    def _load_mcp_registry(self) -> Dict[str, dict]:
        """Load known MCP server registry"""
        
        return {
            'official_mcps': {
                'github-mcp': {
                    'name': 'GitHub MCP',
                    'description': 'GitHub repository management and code analysis',
                    'github_repo': 'modelcontextprotocol/servers',
                    'path': 'src/github',
                    'capabilities': ['github_api', 'repo_management', 'code_analysis', 'issue_management'],
                    'installation_method': 'npm',
                    'category': 'development'
                },
                'docker-mcp': {
                    'name': 'Docker MCP',
                    'description': 'Docker container management and operations',
                    'github_repo': 'modelcontextprotocol/servers',
                    'path': 'src/docker',
                    'capabilities': ['docker_api', 'container_management', 'image_operations', 'compose_management'],
                    'installation_method': 'npm',
                    'category': 'infrastructure'
                },
                'filesystem-mcp': {
                    'name': 'Filesystem MCP',
                    'description': 'File system operations and management',
                    'github_repo': 'modelcontextprotocol/servers',
                    'path': 'src/filesystem',
                    'capabilities': ['file_operations', 'directory_management', 'file_search', 'permissions'],
                    'installation_method': 'npm',
                    'category': 'system'
                },
                'browser-mcp': {
                    'name': 'Browser MCP (Puppeteer)',
                    'description': 'Web browsing and automation capabilities',
                    'github_repo': 'modelcontextprotocol/servers',
                    'path': 'src/puppeteer',
                    'capabilities': ['web_browsing', 'automation', 'data_extraction', 'screenshot'],
                    'installation_method': 'npm',
                    'category': 'automation'
                },
                'slack-mcp': {
                    'name': 'Slack MCP',
                    'description': 'Slack workspace integration',
                    'github_repo': 'modelcontextprotocol/servers',
                    'path': 'src/slack',
                    'capabilities': ['slack_api', 'message_management', 'channel_operations', 'user_management'],
                    'installation_method': 'npm',
                    'category': 'communication'
                },
                'sqlite-mcp': {
                    'name': 'SQLite MCP',
                    'description': 'SQLite database operations',
                    'github_repo': 'modelcontextprotocol/servers',
                    'path': 'src/sqlite',
                    'capabilities': ['database_operations', 'sql_queries', 'schema_management', 'data_import'],
                    'installation_method': 'npm',
                    'category': 'database'
                }
            },
            'search_sources': [
                'https://github.com/modelcontextprotocol/servers',
                'https://github.com/topics/mcp',
                'https://github.com/topics/model-context-protocol',
                'https://github.com/search?q=mcp+server+in:name'
            ]
        }
    
    async def search_github_for_mcps(self, query: str, limit: int = 20) -> List[dict]:
        """Search GitHub for MCP servers based on query"""
        
        try:
            logger.info(f"ðŸ” Searching GitHub for MCP servers: {query}")
            
            if not self.github_client:
                return await self._fallback_github_search(query, limit)
            
            # Search strategies
            search_queries = [
                f"{query} mcp server",
                f"{query} model context protocol",
                f"mcp {query}",
                f"{query} in:name mcp",
                f"{query} in:description model-context-protocol"
            ]
            
            all_results = []
            seen_repos = set()
            
            for search_query in search_queries:
                try:
                    # Search repositories
                    repos = self.github_client.search_repositories(
                        query=search_query,
                        sort='stars',
                        order='desc'
                    )
                    
                    for repo in repos[:limit // len(search_queries) + 5]:
                        if repo.full_name in seen_repos:
                            continue
                        
                        seen_repos.add(repo.full_name)
                        
                        # Analyze if this is likely an MCP server
                        mcp_score = self._analyze_mcp_likelihood(repo)
                        
                        if mcp_score > 0.3:  # Only include likely MCP servers
                            mcp_data = await self._extract_mcp_data_from_repo(repo)\n                            if mcp_data:\n                                mcp_data['confidence'] = mcp_score\n                                all_results.append(mcp_data)\n                    \n                    # Small delay to respect rate limits\n                    await asyncio.sleep(0.5)\n                    \n                except Exception as e:\n                    logger.warning(f\"âš ï¸ Error in GitHub search '{search_query}': {e}\")\n                    continue\n            \n            # Sort by confidence and stars\n            all_results.sort(key=lambda x: (x.get('confidence', 0), x.get('stars', 0)), reverse=True)\n            \n            logger.info(f\"âœ… Found {len(all_results)} potential MCP servers on GitHub\")\n            return all_results[:limit]\n            \n        except Exception as e:\n            logger.error(f\"âŒ GitHub MCP search failed: {e}\")\n            return await self._fallback_github_search(query, limit)\n    \n    def _analyze_mcp_likelihood(self, repo) -> float:\n        \"\"\"Analyze repository to determine MCP likelihood\"\"\"\n        \n        score = 0.0\n        \n        # Check name\n        name_lower = repo.name.lower()\n        if 'mcp' in name_lower:\n            score += 0.4\n        if 'model-context-protocol' in name_lower or 'model_context_protocol' in name_lower:\n            score += 0.5\n        if 'server' in name_lower:\n            score += 0.2\n        \n        # Check description\n        if repo.description:\n            desc_lower = repo.description.lower()\n            if 'mcp' in desc_lower or 'model context protocol' in desc_lower:\n                score += 0.3\n            if 'server' in desc_lower:\n                score += 0.1\n        \n        # Check topics\n        if hasattr(repo, 'get_topics'):\n            try:\n                topics = [topic.name.lower() for topic in repo.get_topics()]\n                if 'mcp' in topics:\n                    score += 0.4\n                if 'model-context-protocol' in topics:\n                    score += 0.5\n            except:\n                pass\n        \n        # Check language (TypeScript/Python are common for MCP)\n        if repo.language in ['TypeScript', 'Python', 'JavaScript']:\n            score += 0.1\n        \n        # Star count bonus\n        if repo.stargazers_count > 10:\n            score += min(0.2, repo.stargazers_count / 1000)\n        \n        return min(1.0, score)\n    \n    async def _extract_mcp_data_from_repo(self, repo) -> Optional[dict]:\n        \"\"\"Extract MCP server data from GitHub repository\"\"\"\n        \n        try:\n            # Check for package.json or setup.py to determine installation method\n            installation_method = 'manual'\n            capabilities = []\n            \n            try:\n                # Try to get package.json\n                package_json = repo.get_contents('package.json')\n                if package_json:\n                    installation_method = 'npm'\n                    # Try to parse package.json for more info\n                    try:\n                        package_data = json.loads(package_json.decoded_content.decode('utf-8'))\n                        if 'scripts' in package_data and 'mcp' in str(package_data.get('scripts', {})).lower():\n                            capabilities.append('mcp_server')\n                    except:\n                        pass\n            except:\n                try:\n                    # Try to get setup.py or pyproject.toml\n                    setup_py = repo.get_contents('setup.py')\n                    if setup_py:\n                        installation_method = 'pip'\n                except:\n                    try:\n                        pyproject = repo.get_contents('pyproject.toml')\n                        if pyproject:\n                            installation_method = 'pip'\n                    except:\n                        pass\n            \n            # Try to detect capabilities from README or description\n            capabilities.extend(self._detect_capabilities_from_text(\n                f\"{repo.name} {repo.description or ''}\"\n            ))\n            \n            return {\n                'id': f\"github_{repo.full_name.replace('/', '_')}\",\n                'name': repo.name.replace('-', ' ').title(),\n                'description': repo.description or f\"MCP server from {repo.full_name}\",\n                'url': repo.html_url,\n                'clone_url': repo.clone_url,\n                'github_repo': repo.full_name,\n                'capabilities': list(set(capabilities)) or ['custom_mcp'],\n                'installation_method': installation_method,\n                'status': 'available',\n                'stars': repo.stargazers_count,\n                'language': repo.language,\n                'source': 'github',\n                'last_updated': repo.updated_at.isoformat() if repo.updated_at else None,\n                'default_branch': repo.default_branch\n            }\n            \n        except Exception as e:\n            logger.warning(f\"âš ï¸ Error extracting MCP data from {repo.full_name}: {e}\")\n            return None\n    \n    def _detect_capabilities_from_text(self, text: str) -> List[str]:\n        \"\"\"Detect capabilities from repository name/description\"\"\"\n        \n        text_lower = text.lower()\n        capabilities = []\n        \n        capability_keywords = {\n            'github': ['github', 'git', 'repository', 'repo'],\n            'docker': ['docker', 'container', 'containerization'],\n            'file_operations': ['file', 'filesystem', 'fs', 'directory'],\n            'web_browsing': ['browser', 'web', 'scraping', 'puppeteer', 'selenium'],\n            'database': ['database', 'db', 'sql', 'sqlite', 'mysql', 'postgres'],\n            'api_integration': ['api', 'rest', 'webhook', 'http'],\n            'slack': ['slack', 'messaging'],\n            'discord': ['discord'],\n            'email': ['email', 'smtp', 'mail'],\n            'automation': ['automation', 'workflow', 'ci', 'cd'],\n            'monitoring': ['monitoring', 'metrics', 'logging'],\n            'cloud': ['aws', 'azure', 'gcp', 'cloud'],\n            'ai_ml': ['ai', 'ml', 'machine learning', 'artificial intelligence']\n        }\n        \n        for capability, keywords in capability_keywords.items():\n            if any(keyword in text_lower for keyword in keywords):\n                capabilities.append(capability)\n        \n        return capabilities\n    \n    async def _fallback_github_search(self, query: str, limit: int) -> List[dict]:\n        \"\"\"Fallback GitHub search using REST API\"\"\"\n        \n        try:\n            search_url = f\"https://api.github.com/search/repositories\"\n            headers = {}\n            if self.github_token:\n                headers['Authorization'] = f'token {self.github_token}'\n            \n            params = {\n                'q': f'{query} mcp server',\n                'sort': 'stars',\n                'order': 'desc',\n                'per_page': min(limit, 30)\n            }\n            \n            response = requests.get(search_url, headers=headers, params=params)\n            response.raise_for_status()\n            \n            data = response.json()\n            results = []\n            \n            for repo in data.get('items', [])[:limit]:\n                # Basic MCP likelihood check\n                name_desc = f\"{repo['name']} {repo.get('description', '')}\".lower()\n                if 'mcp' in name_desc or 'model' in name_desc:\n                    results.append({\n                        'id': f\"github_{repo['full_name'].replace('/', '_')}\",\n                        'name': repo['name'].replace('-', ' ').title(),\n                        'description': repo.get('description', f\"MCP server from {repo['full_name']}\"),\n                        'url': repo['html_url'],\n                        'clone_url': repo['clone_url'],\n                        'github_repo': repo['full_name'],\n                        'capabilities': self._detect_capabilities_from_text(name_desc),\n                        'installation_method': 'manual',\n                        'status': 'available',\n                        'stars': repo['stargazers_count'],\n                        'language': repo.get('language'),\n                        'source': 'github',\n                        'confidence': 0.5\n                    })\n            \n            return results\n            \n        except Exception as e:\n            logger.error(f\"âŒ Fallback GitHub search failed: {e}\")\n            return []\n    \n    async def install_mcp_server(self, mcp_data: dict, user_id: str) -> dict:\n        \"\"\"Install MCP server based on installation method\"\"\"\n        \n        try:\n            logger.info(f\"ðŸ”§ Installing MCP server: {mcp_data['name']}\")\n            \n            installation_method = mcp_data.get('installation_method', 'manual')\n            \n            if installation_method == 'npm':\n                return await self._install_npm_mcp(mcp_data, user_id)\n            elif installation_method == 'pip':\n                return await self._install_pip_mcp(mcp_data, user_id)\n            elif installation_method == 'docker':\n                return await self._install_docker_mcp(mcp_data, user_id)\n            else:\n                return await self._install_manual_mcp(mcp_data, user_id)\n                \n        except Exception as e:\n            logger.error(f\"âŒ MCP installation failed: {e}\")\n            return {\n                'success': False,\n                'error': str(e),\n                'message': f\"Failed to install {mcp_data['name']}: {str(e)}\"\n            }\n    \n    async def _install_npm_mcp(self, mcp_data: dict, user_id: str) -> dict:\n        \"\"\"Install NPM-based MCP server\"\"\"\n        \n        try:\n            # Clone repository\n            clone_url = mcp_data.get('clone_url')\n            if not clone_url:\n                raise ValueError(\"No clone URL provided\")\n            \n            install_dir = f\"/tmp/mcp_installs/{mcp_data['id']}\"\n            \n            # Clone\n            clone_result = subprocess.run(\n                ['git', 'clone', clone_url, install_dir],\n                capture_output=True, text=True, timeout=60\n            )\n            \n            if clone_result.returncode != 0:\n                raise Exception(f\"Git clone failed: {clone_result.stderr}\")\n            \n            # Check if this is a monorepo with multiple MCP servers\n            mcp_path = mcp_data.get('path', '')\n            if mcp_path:\n                install_dir = os.path.join(install_dir, mcp_path)\n            \n            # Install dependencies\n            install_result = subprocess.run(\n                ['npm', 'install'],\n                cwd=install_dir,\n                capture_output=True, text=True, timeout=120\n            )\n            \n            if install_result.returncode != 0:\n                raise Exception(f\"NPM install failed: {install_result.stderr}\")\n            \n            # Build if needed\n            build_result = subprocess.run(\n                ['npm', 'run', 'build'],\n                cwd=install_dir,\n                capture_output=True, text=True, timeout=120\n            )\n            \n            # Register installation\n            self.installed_mcps[mcp_data['id']] = {\n                **mcp_data,\n                'status': 'installed',\n                'install_path': install_dir,\n                'installed_at': datetime.now().isoformat(),\n                'user_id': user_id\n            }\n            \n            logger.info(f\"âœ… NPM MCP server installed: {mcp_data['name']}\")\n            \n            return {\n                'success': True,\n                'mcp_id': mcp_data['id'],\n                'install_path': install_dir,\n                'message': f\"Successfully installed {mcp_data['name']} via NPM\",\n                'capabilities': mcp_data.get('capabilities', [])\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ NPM MCP installation failed: {e}\")\n            raise\n    \n    async def _install_docker_mcp(self, mcp_data: dict, user_id: str) -> dict:\n        \"\"\"Install Docker-based MCP server\"\"\"\n        \n        try:\n            if not self.docker_client:\n                raise Exception(\"Docker client not available\")\n            \n            # Build Docker image from repository\n            clone_url = mcp_data.get('clone_url')\n            if not clone_url:\n                raise ValueError(\"No clone URL provided\")\n            \n            # Clone repository to temporary location\n            import tempfile\n            with tempfile.TemporaryDirectory() as temp_dir:\n                clone_result = subprocess.run(\n                    ['git', 'clone', clone_url, temp_dir],\n                    capture_output=True, text=True, timeout=60\n                )\n                \n                if clone_result.returncode != 0:\n                    raise Exception(f\"Git clone failed: {clone_result.stderr}\")\n                \n                # Check for Dockerfile\n                dockerfile_path = os.path.join(temp_dir, 'Dockerfile')\n                if not os.path.exists(dockerfile_path):\n                    # Create a basic Dockerfile if none exists\n                    dockerfile_content = f\"\"\"FROM node:18\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\nEXPOSE 3000\nCMD [\"npm\", \"start\"]\"\"\"\n                    with open(dockerfile_path, 'w') as f:\n                        f.write(dockerfile_content)\n                \n                # Build Docker image\n                image_tag = f\"mcp-{mcp_data['id']}:latest\"\n                \n                try:\n                    image, build_logs = self.docker_client.images.build(\n                        path=temp_dir,\n                        tag=image_tag,\n                        rm=True\n                    )\n                    \n                    logger.info(f\"ðŸ³ Docker image built: {image_tag}\")\n                    \n                    # Register installation\n                    self.installed_mcps[mcp_data['id']] = {\n                        **mcp_data,\n                        'status': 'installed',\n                        'docker_image': image_tag,\n                        'installed_at': datetime.now().isoformat(),\n                        'user_id': user_id\n                    }\n                    \n                    return {\n                        'success': True,\n                        'mcp_id': mcp_data['id'],\n                        'docker_image': image_tag,\n                        'message': f\"Successfully installed {mcp_data['name']} as Docker container\",\n                        'capabilities': mcp_data.get('capabilities', [])\n                    }\n                    \n                except docker.errors.BuildError as e:\n                    logger.error(f\"âŒ Docker build failed: {e}\")\n                    raise Exception(f\"Docker build failed: {str(e)}\")\n            \n        except Exception as e:\n            logger.error(f\"âŒ Docker MCP installation failed: {e}\")\n            raise\n    \n    async def _install_manual_mcp(self, mcp_data: dict, user_id: str) -> dict:\n        \"\"\"Install MCP server manually (clone and setup)\"\"\"\n        \n        try:\n            clone_url = mcp_data.get('clone_url')\n            if not clone_url:\n                raise ValueError(\"No clone URL provided\")\n            \n            install_dir = f\"/tmp/mcp_installs/{mcp_data['id']}\"\n            \n            # Clone repository\n            clone_result = subprocess.run(\n                ['git', 'clone', clone_url, install_dir],\n                capture_output=True, text=True, timeout=60\n            )\n            \n            if clone_result.returncode != 0:\n                raise Exception(f\"Git clone failed: {clone_result.stderr}\")\n            \n            # Register as manually installed\n            self.installed_mcps[mcp_data['id']] = {\n                **mcp_data,\n                'status': 'installed',\n                'install_path': install_dir,\n                'installed_at': datetime.now().isoformat(),\n                'user_id': user_id,\n                'manual_setup_required': True\n            }\n            \n            logger.info(f\"âœ… Manual MCP server cloned: {mcp_data['name']}\")\n            \n            return {\n                'success': True,\n                'mcp_id': mcp_data['id'],\n                'install_path': install_dir,\n                'message': f\"Successfully cloned {mcp_data['name']} - manual setup may be required\",\n                'capabilities': mcp_data.get('capabilities', []),\n                'manual_setup_required': True\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Manual MCP installation failed: {e}\")\n            raise\n    \n    def get_installed_mcps(self) -> List[dict]:\n        \"\"\"Get list of installed MCP servers\"\"\"\n        \n        return [\n            {\n                'id': mcp_id,\n                'name': mcp_data.get('name'),\n                'description': mcp_data.get('description'),\n                'capabilities': mcp_data.get('capabilities', []),\n                'status': mcp_data.get('status'),\n                'installed_at': mcp_data.get('installed_at'),\n                'installation_method': mcp_data.get('installation_method'),\n                'install_path': mcp_data.get('install_path'),\n                'docker_image': mcp_data.get('docker_image')\n            }\n            for mcp_id, mcp_data in self.installed_mcps.items()\n        ]\n    \n    def get_available_mcps(self) -> List[dict]:\n        \"\"\"Get list of available MCP servers from registry\"\"\"\n        \n        available = []\n        \n        for mcp_id, mcp_data in self.mcp_registry['official_mcps'].items():\n            available.append({\n                'id': mcp_id,\n                'name': mcp_data['name'],\n                'description': mcp_data['description'],\n                'github_repo': mcp_data['github_repo'],\n                'capabilities': mcp_data['capabilities'],\n                'installation_method': mcp_data['installation_method'],\n                'category': mcp_data['category'],\n                'status': 'installed' if mcp_id in self.installed_mcps else 'available',\n                'source': 'official',\n                'url': f\"https://github.com/{mcp_data['github_repo']}\"\n            })\n        \n        return available\n    \n    async def empower_mama_bear_with_browser_tools(self) -> dict:\n        \"\"\"Specifically empower Mama Bear with browser automation capabilities\"\"\"\n        \n        try:\n            logger.info(\"ðŸŒ Empowering Mama Bear with browser tools...\")\n            \n            # Check if browser MCP is already installed\n            browser_mcp_id = 'browser-mcp'\n            if browser_mcp_id not in self.installed_mcps:\n                # Install browser MCP\n                browser_mcp_data = {\n                    'id': browser_mcp_id,\n                    'name': 'Browser MCP (Puppeteer)',\n                    'description': 'Web browsing and automation capabilities for Mama Bear',\n                    'clone_url': 'https://github.com/modelcontextprotocol/servers.git',\n                    'path': 'src/puppeteer',\n                    'capabilities': ['web_browsing', 'automation', 'data_extraction', 'screenshot'],\n                    'installation_method': 'npm',\n                    'source': 'official'\n                }\n                \n                install_result = await self.install_mcp_server(browser_mcp_data, 'mama_bear')\n                \n                if not install_result['success']:\n                    return {\n                        'success': False,\n                        'error': install_result.get('error'),\n                        'message': 'Failed to install browser tools for Mama Bear'\n                    }\n            \n            return {\n                'success': True,\n                'empowerment_type': 'browser_tools',\n                'capabilities_added': [\n                    'autonomous_web_browsing',\n                    'data_extraction_from_websites', \n                    'github_mcp_search',\n                    'marketplace_discovery',\n                    'screenshot_capture',\n                    'form_automation'\n                ],\n                'message': 'ðŸ» Mama Bear is now empowered with browser automation tools! She can autonomously browse the web, search for MCP servers, and gather information.',\n                'usage_examples': [\n                    'Search GitHub for new MCP servers',\n                    'Extract data from websites',\n                    'Take screenshots for documentation',\n                    'Automate web-based workflows',\n                    'Monitor web resources for changes'\n                ]\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Browser empowerment failed: {e}\")\n            return {\n                'success': False,\n                'error': str(e),\n                'message': f'Failed to empower Mama Bear with browser tools: {str(e)}'\n            }\n    \n    async def auto_discover_and_suggest_mcps(self, task_description: str) -> dict:\n        \"\"\"Automatically discover and suggest MCP servers for a given task\"\"\"\n        \n        try:\n            logger.info(f\"ðŸ” Auto-discovering MCPs for task: {task_description}\")\n            \n            # Extract keywords from task description\n            task_keywords = self._extract_task_keywords(task_description)\n            \n            # Search for relevant MCP servers\n            suggested_mcps = []\n            \n            for keyword in task_keywords:\n                search_results = await self.search_github_for_mcps(keyword, limit=5)\n                suggested_mcps.extend(search_results)\n            \n            # Remove duplicates and rank by relevance\n            unique_mcps = {}\n            for mcp in suggested_mcps:\n                if mcp['id'] not in unique_mcps:\n                    unique_mcps[mcp['id']] = mcp\n            \n            # Rank by confidence and relevance\n            ranked_mcps = sorted(\n                unique_mcps.values(),\n                key=lambda x: (x.get('confidence', 0), x.get('stars', 0)),\n                reverse=True\n            )[:5]\n            \n            return {\n                'success': True,\n                'task_description': task_description,\n                'suggested_mcps': ranked_mcps,\n                'discovery_keywords': task_keywords,\n                'message': f'ðŸ» Found {len(ranked_mcps)} MCP servers that could help with your task!'\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Auto-discovery failed: {e}\")\n            return {\n                'success': False,\n                'error': str(e),\n                'message': f'Failed to auto-discover MCPs: {str(e)}'\n            }\n    \n    def _extract_task_keywords(self, task_description: str) -> List[str]:\n        \"\"\"Extract relevant keywords from task description\"\"\"\n        \n        task_lower = task_description.lower()\n        keywords = []\n        \n        # Service/platform keywords\n        services = [\n            'github', 'gitlab', 'bitbucket',\n            'docker', 'kubernetes', 'container',\n            'slack', 'discord', 'telegram',\n            'aws', 'azure', 'gcp', 'cloud',\n            'database', 'sql', 'postgres', 'mysql',\n            'email', 'smtp', 'notification',\n            'file', 'filesystem', 'storage',\n            'browser', 'web', 'scraping',\n            'api', 'rest', 'webhook',\n            'monitoring', 'logging', 'metrics'\n        ]\n        \n        for service in services:\n            if service in task_lower:\n                keywords.append(service)\n        \n        # Action keywords\n        actions = [\n            'integrate', 'connect', 'automate',\n            'deploy', 'build', 'test',\n            'monitor', 'alert', 'notify',\n            'manage', 'create', 'update'\n        ]\n        \n        for action in actions:\n            if action in task_lower:\n                keywords.append(action)\n        \n        # If no specific keywords found, extract important words\n        if not keywords:\n            words = task_lower.split()\n            important_words = [word for word in words if len(word) > 3 and word not in ['the', 'and', 'with', 'for', 'that', 'this']]\n            keywords.extend(important_words[:3])\n        \n        return list(set(keywords))\n